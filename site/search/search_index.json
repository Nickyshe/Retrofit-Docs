{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is Retrofit","text":"<p>Retrofit is a powerful type-safe HTTP client for Android and Java applications developed by Square. It simplifies communication with web APIs by providing a clean and intuitive way to interact with them. </p>"},{"location":"#benefits-of-retrofit","title":"Benefits of Retrofit:","text":"<ul> <li>Automatic conversion: Retrofit seamlessly converts between JSON/XML data received from APIs and Java objects. This eliminates the need for manual parsing, saving you time and reducing the risk of errors.</li> <li>Intuitive endpoints: Define API endpoints using annotations. These annotations clearly describe the HTTP method (GET, POST, etc.), URL path, and any additional parameters required for the request. </li> <li>Efficient network calls: Retrofit ensures network operations are performed asynchronously, preventing them from blocking the main thread of your application. This keeps your UI responsive while data is being fetched.</li> <li>Customization power: Retrofit offers extensive customization options. You can add converters to support different data formats, use interceptors to modify requests and responses, and leverage call adapters for integrating with reactive programming frameworks like RxJava or Coroutines.</li> </ul>"},{"location":"#use-case","title":"Use Case","text":"<p>Here are some practical applications of Retrofit:</p> <ul> <li>Fetching Data: Effortlessly fetch data from various REST APIs. This could include retrieving weather updates, news headlines, or social media posts. </li> <li>Uploading Files:  Retrofit simplifies uploading files (like images or documents) to a server. You can define endpoints that accept file data and handle the upload process efficiently.</li> <li>Authentication and Authorization: Implement robust authentication and authorization mechanisms for your app. Retrofit allows you to send credentials (e.g., username, password, access tokens) securely to the server for user validation.</li> <li>Reactive Programming Integration:  Combine Retrofit with RxJava or Coroutines to create a reactive programming approach for handling asynchronous network operations. This leads to cleaner and more maintainable code.</li> </ul>"},{"location":"api-declaration/","title":"API Declaration with Annotation","text":"<p>Retrofit uses annotations on your interface methods to understand how to interact with the web API. These annotations basically act as instructions, telling Retrofit what kind of request to make and how to handle the data.</p>"},{"location":"api-declaration/#choosing-the-right-request-method","title":"Choosing the Right Request Method","text":"<p>The first thing Retrofit needs to know is the type of HTTP request you want to make. There are eight built-in annotations for this purpose:</p> <ul> <li><code>@GET</code>: Used for retrieving data from the server.</li> <li><code>@POST</code>: Used for sending data to create something on the server (e.g., a new user).</li> <li><code>@PUT</code>: Used for updating existing data on the server.</li> <li><code>@PATCH</code>: Used for partial updates of data on the server.</li> <li><code>@DELETE</code>: Used for deleting data from the server.</li> <li><code>@OPTIONS</code>: Used to retrieve information about the communication options of the server.</li> <li><code>@HEAD</code>: Used to retrieve only the header information of a request (without the actual data).</li> </ul> <p>You'll place the appropriate annotation at the beginning of your interface method, followed by the relative URL of the resource you want to access. Here's an example using <code>@GET</code>:</p> <pre><code>@GET(\"users/list\")\n</code></pre> <p>This tells Retrofit to make a GET request to the \"/users/list\" endpoint on the server.</p>"},{"location":"api-declaration/#adding-details-with-query-parameters","title":"Adding Details with Query Parameters","text":"<p>You can also include additional information in your request using query parameters. These are appended to the URL as a question mark (?) followed by key-value pairs separated by ampersands (&amp;). In Retrofit, you can specify these directly in the URL within the annotation.</p> <p>For instance, you might want to retrieve a list of users sorted by descending order:</p> <pre><code>@GET(\"users/list?sort=desc\")\n</code></pre> <p>This adds a query parameter named \"sort\" with the value \"desc\" to the request URL.</p>"},{"location":"api-declaration/#url-manipulation","title":"URL Manipulation","text":"<p>Retrofit lets you build URLs that adapt to your needs. You can use replacement blocks enclosed in curly braces <code>{}</code> within the URL. These blocks are then filled with corresponding parameters annotated with <code>@Path</code>. </p> <p>For example:</p> <pre><code>@GET(\"group/{id}/users\")\nCall&lt;List&lt;User&gt;&gt; groupList(@Path(\"id\") int groupId);\n</code></pre> <p>Here, <code>@GET(\"group/{id}/users\")</code> defines the URL pattern. When you call <code>groupList(123)</code>, Retrofit replaces <code>{id}</code> with the value <code>123</code>, resulting in a request to \"group/123/users\".</p> <p>Adding Query Parameters</p> <p>You can include additional information in your requests using query parameters. These appear as key-value pairs appended to the URL with a question mark (<code>?</code>). Retrofit allows you to specify them directly within the URL of your annotated method:</p> <pre><code>@GET(\"group/{id}/users\")\nCall&lt;List&lt;User&gt;&gt; groupList(@Path(\"id\") int groupId, @Query(\"sort\") String sort);\n</code></pre> <p>This example retrieves a list of users from group <code>groupId</code> sorted by the value of the <code>sort</code> parameter.</p> <p>For complex scenarios with many query parameters, you can use a <code>Map&lt;String, String&gt;</code> annotated with <code>@QueryMap</code>.</p>"},{"location":"api-declaration/#sending-data-in-the-request-body","title":"Sending Data in the Request Body","text":"<p>You can include data in the request body using the <code>@Body</code> annotation. This is typically used for creating new resources on the server. The object you provide is automatically converted using a converter configured for your Retrofit instance. If no converter is specified, you can only use the <code>RequestBody</code> class.</p> <p>Here's an example of creating a new user:</p> <pre><code>@POST(\"users/new\")\nCall&lt;User&gt; createUser(@Body User user);\n</code></pre>"},{"location":"api-declaration/#form-encoded-and-multipart-requests","title":"Form-Encoded and Multipart Requests","text":"<p>Retrofit also supports sending data in other formats:</p> <ul> <li> <p>Form-encoded data: Use the <code>@FormUrlEncoded</code> annotation on the method and <code>@Field</code> annotations on individual parameters to specify key-value pairs. <pre><code>@FormUrlEncoded\n@POST(\"user/edit\")\nCall&lt;User&gt; updateUser(@Field(\"first_name\") String first, @Field(\"last_name\") String last);\n</code></pre></p> </li> <li> <p>Multipart requests: Use the <code>@Multipart</code> annotation for methods that handle data with multiple parts, like file uploads. Each part is declared with the <code>@Part</code> annotation.</p> </li> </ul> <pre><code>@Multipart\n@PUT(\"user/photo\")\nCall&lt;User&gt; updateUser(@Part(\"photo\") RequestBody photo, @Part(\"description\") RequestBody description);\n</code></pre>"},{"location":"api-declaration/#managing-request-headers","title":"Managing Request Headers","text":"<p>You can set headers for your requests using annotations:</p> <ul> <li>Static headers: Use the <code>@Headers</code> annotation to define static headers for a specific method.</li> </ul> <p><pre><code>@Headers(\"Cache-Control: max-age=640000\")\n@GET(\"widget/list\")\nCall&lt;List&lt;Widget&gt;&gt; widgetList();\n</code></pre> - Dynamic headers: Use the <code>@Header</code> annotation with a corresponding parameter to set headers dynamically. You can also use a <code>Map&lt;String, String&gt;</code> with <code>@HeaderMap</code> for complex scenarios.</p> <pre><code>@Headers({\n    \"Accept: application/vnd.github.v3.full+json\",\n    \"User-Agent: Retrofit-Sample-App\"\n})\n@GET(\"users/{username}\")\nCall&lt;User&gt; getUser(@Path(\"username\") String username);\n</code></pre>"},{"location":"api-declaration/#synchronous-vs-asynchronous-calls","title":"Synchronous vs. Asynchronous Calls","text":"<p>Retrofit calls can be executed either synchronously (blocking the current thread) or asynchronously. Each <code>Call</code> instance can only be used once, but you can create a copy using the <code>clone()</code> method.</p> <p>Kotlin Support</p> <p>Retrofit offers special features for Kotlin development:</p> <ul> <li> <p>Suspend functions: Interface methods can be suspend functions returning a <code>Response</code> object directly. This allows asynchronous execution while suspending the current function. <pre><code>@GET(\"users\")\nsuspend fun getUser(): Response&lt;User&gt;\n</code></pre></p> </li> <li> <p>Direct body return: Suspend functions can also return the response body directly. If the response code is not successful (2XX), an <code>HttpException</code> containing the response will be thrown. <pre><code>@GET(\"users\")\nsuspend fun getUser(): User\n</code></pre></p> </li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p> <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running ./gradlew build (or gradlew.bat build for Windows).</p> <p>Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA).</p>"},{"location":"license/","title":"License","text":"<p>Copyright 2013 Square, Inc.</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"requirement/","title":"Requirement","text":"<p>Retrofit requires at minimum Java 8+ or Android API 21+.</p> <p>R8 / PROGUARD</p> <p>If you are using R8 the shrinking and obfuscation rules are included automatically.</p> <p>ProGuard users must manually add the options from retrofit2.pro.</p> <p>You might also need rules for OkHttp and Okio which are dependencies of this library.</p>"},{"location":"retrofit-configuration/","title":"Retrofit Configuration","text":"<p>Retrofit is the class through which your API interfaces are turned into callable objects. While Retrofit offers reasonable defaults, you can customize it for your project's specific requirements.</p>"},{"location":"retrofit-configuration/#converters","title":"Converters","text":"<p>By default, Retrofit can only deserialize HTTP bodies into OkHttp's <code>ResponseBody</code> type and it can only accept its <code>RequestBody</code> type for <code>@Body.</code></p> <p>Converters can be added to support other types. Sibling modules adapt popular serialization libraries for your convenience.</p> <ul> <li>Gson: com.squareup.retrofit2:converter-gson</li> <li>Jackson: com.squareup.retrofit2:converter-jackson</li> <li>Mosh: com.squareup.retrofit2:converter-moshi</li> <li>Protobuf: com.squareup.retrofit2:converter-protobuf</li> <li>Wire: com.squareup.retrofit2:converter-wire</li> <li>Simple XML: com.squareup.retrofit2:converter-simplexml</li> <li>JAXB: com.squareup.retrofit2:converter-jaxb</li> <li>Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars</li> </ul> <p>Here's an example of using the GsonConverterFactory class to generate an implementation of the GitHubService interface which uses Gson for its deserialization.</p> <pre><code>Retrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"https://api.github.com/\")\n    .addConverterFactory(GsonConverterFactory.create())\n    .build();\n\nGitHubService service = retrofit.create(GitHubService.class);\n</code></pre>"},{"location":"retrofit-configuration/#custom-converters","title":"Custom Converters","text":"<p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. </p> <p>Create a class that extends the Converter.Factory class and pass in an instance when building your adapter.</p>"},{"location":"setup/","title":"Setting Up Retrofit","text":"<p>Retrofit simplifies making network calls in Android applications. Here's a step-by-step guide to set it up:</p>"},{"location":"setup/#add-retrofit-as-a-dependency","title":"Add Retrofit as a dependency","text":"<ul> <li>Open your project's <code>build.gradle</code> file (located in the <code>app</code> module).</li> <li>Add the following dependencies in the <code>dependencies</code> block:</li> </ul> <p><pre><code>dependencies {\n    // Other dependencies\n    implementation 'com.squareup.retrofit2:retrofit:2.9.0'\n    implementation 'com.squareup.retrofit2:converter-gson:2.9.0'\n}\n</code></pre> Replace <code>2.9.0</code> with the latest stable version if needed (check Retrofit documentation for updates).</p> <p>Sync your project with Gradle to download the libraries.</p> <p>Maven <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.squareup.retrofit2&lt;/groupId&gt;\n  &lt;artifactId&gt;retrofit&lt;/artifactId&gt;\n  &lt;version&gt;(insert latest version)&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre></p>"},{"location":"setup/#create-a-retrofit-instance","title":"Create a Retrofit Instance","text":"<p>You need a <code>Retrofit</code> object to make network requests. Here's how to create one:</p> <p>In this example, you would use the generated <code>GitHubService</code> object:</p> <pre><code>Retrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"https://api.github.com/\")\n    .build();\n\nGitHubService service = retrofit.create(GitHubService.class);\n\nCall&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(\"octocat\");\n</code></pre> <p>This code creates a <code>Retrofit</code> instance with the base URL of the GitHub API. Then, it uses this instance to create a <code>GitHubService</code> object. Finally, you can call the <code>listRepos</code> method on the service, passing the username \"octocat\" as an argument. This initiates a network request to retrieve the list of repositories for that user.</p>"},{"location":"setup/#define-an-api-interface","title":"Define an API Interface","text":"<p>Create an interface that defines your API endpoints. This interface acts as a contract for your network calls.</p> <p>Here's an example:</p> <pre><code>public interface GitHubService {\n  @GET(\"users/{user}/repos\")\n  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(\"user\") String user);\n}\n</code></pre> <p>This interface, <code>GitHubService</code>, defines a single method, <code>listRepos</code>. The <code>@GET</code> annotation tells Retrofit that this method makes a GET request. </p> <p>The <code>{user}</code> part in the URL indicates a placeholder that will be replaced with a specific username when the call is made. The <code>@Path(\"user\")</code> annotation links the <code>user</code> parameter in the method with the <code>{user}</code> placeholder.</p> <p>Once you've defined the interface, Retrofit generates an object that implements it at runtime. This object handles all the heavy lifting of making the network request, converting the response data into your desired format (like a list of repositories in this case), and notifying you of any errors.</p>"},{"location":"setup/#key-features-of-retrofit-annotations","title":"Key Features of Retrofit Annotations","text":"<ul> <li>URL parameter replacement: You can use placeholders in the URL to represent dynamic parts, like the username in the example.</li> <li>Query parameter support: Annotations allow you to specify additional parameters that are appended to the URL as a query string.</li> <li>Object conversion: Retrofit can automatically convert objects to JSON or other data formats for request bodies and parse responses back into your desired Java classes.</li> <li>Multipart request body and file upload: Retrofit supports building complex requests with multiple parts, including file uploads.</li> </ul>"}]}